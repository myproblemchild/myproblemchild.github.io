<head>
    <title>Grid problem, range sum query, Fenwick tree</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-mml-chtml.js"></script>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/default.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <h1>
        <center>Example for range sum query</center>
    </h1>

    I stumbled upon an interesting problem <a id="footnote-1-link" href="#footnote-1">[1]</a> a while ago:

    <pre>
--- Day 6: Probably a Fire Hazard ---
Because your neighbors keep defeating you in the holiday house decorating contest year after year,
you've decided to deploy one million lights in a 1000x1000 grid.
Furthermore, because you've been especially nice this year,
Santa has mailed you instructions on how to display the ideal lighting configuration.
Lights in your grid are numbered from 0 to 999 in each direction;
the lights at each corner are at 0,0, 0,999, 999,999, and 999,0.
The instructions include whether to turn on, turn off,
or toggle various inclusive ranges given as coordinate pairs.
Each coordinate pair represents opposite corners of a rectangle, inclusive;
a coordinate pair like 0,0 through 2,2 therefore refers to 9 lights in a 3x3 square.
The lights all start turned off.
To defeat your neighbors this year, all you have to do is set up your lights by doing
the instructions Santa sent you in order.
For example:
turn on 0,0 through 999,999 would turn on (or leave on) every light.
toggle 0,0 through 999,0 would toggle the first line of 1000 lights,
turning off the ones that were on, and turning on the ones that were off.
turn off 499,499 through 500,500 would turn off (or leave off) the middle four lights.
After following the instructions, how many lights are lit?
---
</pre>

    <h2>Auxiliary setup</h2>
    To compare different approaches, 1000x1000 grid turns out to be too small. To spare myself of having to generate the
    test cases, I will:
    <ul>
        <li>use the input provided by AOC but randomly shuffled:
            <pre><code class="bash">sort -R original_input.txt > shuffled_input.txt</code></pre>
        <li>introduce a coefficient k. The grid size becomes \( k \cdot 1000 \times k \cdot 1000 \) and each input
            coordinate is
            multiplied by k.
            Setting
            k=1 means solving the exact original problem.
    </ul>

    <h2>Naive solution</h2>
    The naive solution is to initialize the 1000x1000 grid, consume input and update the grid according to instructions
    and
    finally count how many grid cells are on.

    <p>A simple optimization can be done to maintain the numbers online, thus not needing to do the final grid
        walkthrough,
        but
        that would still leave the worst case runtime at O( \( R \times N^2 \) ) (R is a number of rectangles, N is the
        side of the grid).

    <p>Example run:
    <pre><code class='bash'>
./target/release/bin 1 naive < src/input_shuffled.txt
211412
</code></pre>

    <h2>Optimized solution</h2>
    One thing that struck me is we, human, can quickly compute the answer for the case when 2 huge rectangles overlap by
    1:
    <pre><code class='bash'>
turn on 0,0 through 500,500
turn on 500,500 through 999,999
turn off 0,0 through 500,500
toggle 500,500 through 999,999
</code></pre>

    <p>Exapmle where humans can quickly compute the answer, no matter the size of the areas covered:</p>
    <img src="./files/grid_problem_2.png" style="max-width:500px;max-height:500px" />

    <p>Note that running this with k=1, k=100, k=1000 should obviously produce the same result of 1 overlapping cell,
        and
        humans would be quick to realize that.
    <p>However, a naive solution would take progressively longer as we increase k.

    <p>The idea of an optimized approach is as follows. We can sweep a vertical line and maintain the set of rectangles
        that
        fall into the current horizontal segment.

    <p>Code 1: sweeping vertical line</p>
    <pre><code class='rs'>
for pair in events_by_x_coord.iter() {
    let x = pair.0;
    if let Some(x_prev_value) = x_prev {
        res += process_vertical_stripe(
            x_prev_value,
            *x,
            &active_set_within_vertical_stripe,
            &events_by_y_coord,
            z_index,
        );
    }
    for e in pair.1 {
        if e.is_open {
            active_set_within_vertical_stripe.insert(e.z_index);
        } else {
            active_set_within_vertical_stripe.remove(&e.z_index);
        }

        x_prev = Some(*pair.0);
    }
}
</code></pre>

    For a given horizontal segment, we can then sweep another - horizontal - line upwards and maintain a set of
    rectangles
    in the current vertical segment.
    While doing that we can check whether the rectangle is in the horizontal segment, that way having an exact set of
    rectangles that are present in the current rectangular patch.

    <p>Code 2: sweeping horizontal line</p>
    <pre><code class="rust">
for p in events_by_y_coord.iter() {
    let y = p.0;
    if let Some(y_prev_val) = y_prev {
        if !active_set_within_horizontal_stripe.is_empty() {
            res += process_patch(
                x_prev_val,
                x,
                y_prev_val,
                *y,
                &active_on_within_horizontal_stripe,
                &active_off_within_horizontal_stripe,
                &fw_toggle,
                total_rectangles,
            );
        }
    }

    y_prev = Some(*y);

    for e in p.1.iter() {
        if !active_set_within_vertical_stripe.contains(&e.z_index) {
            continue;
        }

        match e.is_open {
            true => {
                active_set_within_horizontal_stripe.insert(e.z_index);
                match e.operation {
                    Operation::On => {
                        active_on_within_horizontal_stripe.insert(e.z_index);
                    }
                    Operation::Off => {
                        active_off_within_horizontal_stripe.insert(e.z_index);
                    }
                    Operation::Toggle => {
                        active_toggle_within_horizontal_stripe.insert(e.z_index);
                        fw_toggle.inc(e.z_index as usize);
                    }
                }
            }
            false => {
                active_set_within_horizontal_stripe.remove(&e.z_index);
                match e.operation {
                    Operation::On => {
                        active_on_within_horizontal_stripe.remove(&e.z_index);
                    }
                    Operation::Off => {
                        active_off_within_horizontal_stripe.remove(&e.z_index);
                    }
                    Operation::Toggle => {
                        active_toggle_within_horizontal_stripe.remove(&e.z_index);
                        fw_toggle.dec(e.z_index as usize);
                    }
                }
            }
        }
    }
}
</code></pre>

    <p>The next question is how to process a separate patch.
        The basic idea is this: any sequence of "on", "off" and "toggle" is equivalent to "on" or "off" followed by some
        numbers
        of toggles.

    <p>For example, <code
            style='background-color: gainsboro'>1:"on", 2:"off", 3:"off", 4:"on", 5:"toggle", 6:"on", 7:"toggle"</code>
        is
        equivalent to just
        <code style='background-color: gainsboro'>6:"on", 7:"toggle"</code>
        because the "on" at step 6 makes it irrelevant what was the prior sequence.

    <p>To quickly compute number of toggles that happened after a certain index, we can employ range some query.


    <p>Code 3: figuring out the state of the patch</p>
    <pre><code class="rust">
fn process_patch(
    left: u32,
    right: u32,
    bottom: u32,
    top: u32,
    turn_on: &BTreeSet<i32>,
    turn_off: &BTreeSet<i32>,
    fw_toggle_active: &FenwickTree,
    total_rectangles: i32,
) -> u32 {
    let mut base_val = false;
    let mut last_turn: i32 = *turn_off.last().unwrap_or(&-1);
    if let Some(turn_on_last) = turn_on.last() {
        if *turn_on_last > last_turn {
            last_turn = *turn_on_last;
            base_val = true;
        }
    }

    let toggles_after_last_turn = fw_toggle_active.sum_range(last_turn + 1, total_rectangles - 1);
    if toggles_after_last_turn % 2 == 1 {
        base_val = !base_val;
    }

    if base_val {
        let h = (right - left) as u32;
        let v = (top - bottom) as u32;
        h * v
    } else {
        0
    }
}
</code></pre>

    So we need to maintain the sorted set of "on" and "off" rectangles to quickly identify the last "on" or "off".
    After that we need to know how many toggles happened thereafter - range sum query would work, and one way to do it
    efficiently is via fenwick tree.

    Finally, when we know the last action ("on" or "off") and how many toggles happened afterwards, we can compute the
    state
    of the whole patch (either "on" or "off).
    And knowing the area of the patch we can then add it to the final result.

    <img src="./files/grid_problem.png" style="max-width:500px;max-height:500px" />
    <p>
        In this example we have 3 rectangles: 1, 2, 3.
        We have 5 segments between vertical lines: V1, V2, ..., V5.
        We have 5 segments between horizontal lines: H1, H2, ... H5.

    <h2>Runtime analysis</h2>
    <p>To pre-process input: \( R \log R \) since we read R rectangles and add data to sets and maps.
    <p>To compute result:
    <ul>
        <li> O(\( R \log R \)) to sweep vertical line </li>
        <li> O(\( R \log R \)) to sweep horizontal line</li>
        <li> O(\( \log R \)) to perform range sum query</li>
    </ul>
    Giving O(\( R^2 \log^3 R \))
    <p>Note that it doesn't depend on the size of the grid or of any of the retangles anymore, but only on the number of
        rectangles.


    <h2>Fenwick tree implementation</h2>
    See <a id="footnote-2-link" href="#footnote-2">[2]</a> for the original C++ code.<br>
    See <a id="footnote-7-link" href="#footnote-7">[7]</a> for the adopted Rust implementation based on above.
    <pre>
<code class="rust">
pub struct FenwickTree {
    size: usize,
    t: Vec<u32>,
}

impl FenwickTree {
    pub fn new(n: usize) -> FenwickTree {
        FenwickTree {
            size: n,
            t: vec![0; n as usize],
        }
    }

    pub fn sum(&self, mut range: i32) -> u32 {
        let mut res: u32 = 0;
        while range >= 0 {
            res += self.t[range as usize];
            range = (range & (range + 1)) - 1;
        }
        res
    }

    pub fn inc(&mut self, mut i: usize) {
        while i < self.size {
            self.t[i] += 1;
            i = i | (i + 1);
        }
    }

    pub fn dec(&mut self, mut i: usize) {
        while i < self.size {
            self.t[i] -= 1;
            i = i | (i + 1);
        }
    }

    pub fn sum_range(&self, l: i32, r: i32) -> u32 {
        self.sum(r) - self.sum(l - 1)
    }
}    
</code>
</pre>
    <h2>Experiments</h2>

    <p>The data below has been collected by running the command:</p>
    <pre><code class="bash">
% /usr/bin/time -lh ./target/release/bin 10 naive < src/input_shuffled.txt
20992232
Time: 2431 ms
	2.43s real		2.41s user		0.01s sys
           104857600  maximum resident set size
                   0  average shared memory size
                   0  average unshared data size
                   0  average unshared stack size
                6583  page reclaims
                  13  page faults
                   0  swaps
                   0  block input operations
                   0  block output operations
                   0  messages sent
                   0  messages received
                   0  signals received
                   4  voluntary context switches
                  28  involuntary context switches
         51317968081  instructions retired
          9501259555  cycles elapsed
           104596544  peak memory footprint

% /usr/bin/time -lh ./target/release/bin 10 optimized < src/input_shuffled.txt
20992232
Time: 20 ms
	0.02s real		0.02s user		0.00s sys
             1769472  maximum resident set size
                   0  average shared memory size
                   0  average unshared data size
                   0  average unshared stack size
                 303  page reclaims
                   0  page faults
                   0  swaps
                   0  block input operations
                   0  block output operations
                   0  messages sent
                   0  messages received
                   0  signals received
                   0  voluntary context switches
                  13  involuntary context switches
           119355746  instructions retired
            51174896  cycles elapsed
             1426240  peak memory footprint
    </code></pre>
    The lines above would be producing data points:
    <pre>
        k=10: naive time 2431 ms, naive memory 99.8 Mb
        k=10: optimized time 20 ms, optimized memory 1.4 Mb
    </pre>

    <style>
        .charts-wrapper {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .chart-container {
            flex: 1;
            min-width: 0;
        }

        .chart {
            width: 100%;
            height: 400px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
    </style>

    <div class="charts-wrapper">
        <div class="chart-container">
            <h2>Time Comparison (ms)</h2>
            <div id="timeChart" class="chart"></div>
        </div>
        <div class="chart-container">
            <h2>Memory Comparison (MB)</h2>
            <div id="memoryChart" class="chart"></div>
        </div>
    </div>

    <script>
        const data = [
            { k: 1, naiveTime: 48, naiveMemory: 2.2, optimizedTime: 17, optimizedMemory: 1.1 },
            { k: 10, naiveTime: 2505, naiveMemory: 99.7, optimizedTime: 22, optimizedMemory: 1.3 },
            { k: 20, naiveTime: 9906, naiveMemory: 394.4, optimizedTime: 19, optimizedMemory: 1.2 },
            { k: 50, naiveTime: 63196, naiveMemory: 3129.8, optimizedTime: 22, optimizedMemory: 1.3 },
            { k: 100, naiveTime: 287628, naiveMemory: 12511.4, optimizedTime: 21, optimizedMemory: 1.3 },
            { k: 1000, naiveTime: null, naiveMemory: null, optimizedTime: 21, optimizedMemory: 1.3 }
        ];

        // Filter out nulls for plotting
        const kValues = data.map(d => d.k);
        const naiveTimes = data.map(d => d.naiveTime).filter(v => v !== null);
        const optTimes = data.map(d => d.optimizedTime).filter(v => v !== null);
        const naiveMems = data.map(d => d.naiveMemory).filter(v => v !== null);
        const optMems = data.map(d => d.optimizedMemory).filter(v => v !== null);

        // Time Chart
        const timeTrace1 = {
            x: kValues.slice(0, naiveTimes.length),
            y: naiveTimes,
            mode: 'lines+markers',
            name: 'Naive Time (ms)',
            line: { color: '#ff4d4f', width: 2 },
            marker: { symbol: 'circle', size: 12, color: '#ff4d4f' }
        };
        const timeTrace2 = {
            x: kValues,
            y: optTimes,
            mode: 'lines+markers',
            name: 'Optimized Time (ms)',
            line: { color: '#36cfc9', width: 2 },
            marker: { symbol: 'triangle-up', size: 12, color: '#36cfc9' }
        };
        Plotly.newPlot('timeChart', [timeTrace1, timeTrace2], {
            title: { text: 'Time Comparison', font: { size: 14 } },
            xaxis: { title: 'k', tickvals: kValues, type: 'log', gridcolor: '#e0e0e0' },
            yaxis: { title: 'Time (ms)', gridcolor: '#e0e0e0' },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            margin: { l: 60, r: 40, t: 40, b: 60 },
            showlegend: true,
            legend: {
                orientation: 'h',
                x: 0.5,
                xanchor: 'center',
                y: -0.2,
                yanchor: 'top'
            },
        });

        // Memory Chart
        const memTrace1 = {
            x: kValues.slice(0, naiveMems.length),
            y: naiveMems,
            mode: 'lines+markers',
            name: 'Naive Memory (MB)',
            line: { color: '#ff4d4f', width: 2 },
            marker: { symbol: 'circle', size: 12, color: '#ff4d4f' }
        };
        const memTrace2 = {
            x: kValues,
            y: optMems,
            mode: 'lines+markers',
            name: 'Optimized Memory (MB)',
            line: { color: '#36cfc9', width: 2 },
            marker: { symbol: 'triangle-up', size: 12, color: '#36cfc9' }
        };
        Plotly.newPlot('memoryChart', [memTrace1, memTrace2], {
            title: { text: 'Memory Comparison', font: { size: 14 } },
            xaxis: { title: 'k', tickvals: kValues, type: 'log', gridcolor: '#e0e0e0' },
            yaxis: { title: 'Memory (MB)', gridcolor: '#e0e0e0' },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            margin: { l: 60, r: 40, t: 40, b: 60 },
            showlegend: true,
            legend: {
                orientation: 'h',
                x: 0.5,
                xanchor: 'center',
                y: -0.2,
                yanchor: 'top'
            },
        });
    </script>

    <h2>Full code and references</h2>
    <p id="footnote-1"><b><a href="#footnote-1-link">[1]</a></b> The original problem is taken from here: <a
            href="https://adventofcode.com/2015/day/6">https://adventofcode.com/2015/day/6</a></p>
    <p id="footnote-2"><b><a href="#footnote-2-link">[2]</a></b> The fenwick tree implementation is a rip-off of this:
        <a href="http://e-maxx.ru/algo/fenwick_tree">http://e-maxx.ru/algo/fenwick_tree</a>
    </p>
    <p id="footnote-3"><b>[3]</b> Full source code directory: <a
            href="https://github.com/myproblemchild/myproblemchild.github.io/tree/master/grid-problem-rust">link</a></p>
    <p id="footnote-4"><b>[4]</b> Test file <a
            href="https://github.com/myproblemchild/myproblemchild.github.io/blob/master/grid-problem-rust/src/input_shuffled.txt">input_shuffled.txt</a>
    </p>
    <p id="footnote-5"><b>[5]</b> Test file <a
            href="https://github.com/myproblemchild/myproblemchild.github.io/blob/master/grid-problem-rust/src/easy_for_humans.txt">easy_for_humans.txt</a>
    </p>
    <p id="footnote-6"><b>[6]</b> Full code of <a
            href="https://github.com/myproblemchild/myproblemchild.github.io/blob/master/grid-problem-rust/src/main.rs">main.rs</a>
    <p id="footnote-7"><b><a href="#footnote-7-link">[7]</a></b> Full code of <a
            href="https://github.com/myproblemchild/myproblemchild.github.io/blob/master/grid-problem-rust/src/fw.rs">fw.rs</a>
    </p>

    <p><a href='/'>Back to main page</a>
    <p>&copy; Copyright 2025, Iaroslav Tymchenko

</body>